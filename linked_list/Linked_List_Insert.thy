theory Linked_List_Insert imports
 "/home/dacosta/development/rockwellcollins/l4v/tools/autocorres/AutoCorres"
 "/home/dacosta/development/rockwellcollins/l4v/tools/autocorres/DataStructures"
begin

text{* 

Author: Dan DaCosta
Description: Work towards a correctness proof of an order preserving linked list insert. Insertion
relies on the function, find_insertion, to find the correct placement for the new node. Currently,
there is a proof that find_insertion finds the insertion point according to the following 
statements:

  - find_insertion does not alter the heap

  - if find_insertion returns a non-null node n, then all ancestors of n and n have values less than
  or equal to the value find_insertion was called with.

  - if find_insertion returns a non-null node n and n's direct descendant is not null than n's 
  direct descendant has a value greater than the value of what find_insertion was called with.

  - if find_insertion returns null then either the list find_insertion was called with is null or
  the first element of the list is greater than the value find_insertion was called with.

TODO:
 
 - Requires significant cleanup.

 - A proof that insert uses find_insertion to insert a new element into a linked list preserving
 ascending order must be given.

*}

install_C_file linked_list.c
autocorres [ heap_abs_syntax, ts_rules = nondet] linked_list.c
context linked_list begin

interpretation DataStructures.linked_list next_C NULL
done

text{*

Both of these lemma seem like poor candidates for simplification rules; they both have the 
potential for looping.

*}

declare list_split [simp del]
declare path_split [simp del]

definition lkup :: "lifted_globals \<Rightarrow> ll_C ptr \<Rightarrow> ll_C option" where 
"lkup s a \<equiv> (if is_valid_ll_C s a then Some (s[a]) else None)"

text{*

A useful lemma when using DataStructures.thy. It connects the lkup function to the structure 
notations generated by AutoCorres.

*}

lemma lkup_conv[simp]: "lkup s i = Some j \<Longrightarrow> is_valid_ll_C s i \<and> s[i] = j \<and> next_C j = s[i]\<rightarrow>next \<and> val_C j = s[i]\<rightarrow>val"
by 
  (metis 
    linked_list.get_ll_next_def
    linked_list.get_ll_val_def
    linked_list.lkup_def 
    option.distinct(1) 
    option.sel)

lemma list_null_free: "list (lkup s') xs i \<Longrightarrow> NULL \<notin> set xs"
 apply (induction xs arbitrary: i) by auto

lemma list_member_not_null:"\<lbrakk>list (lkup s') xs i; j \<in> set xs\<rbrakk> \<Longrightarrow> j \<noteq> NULL"
 apply (rule ccontr)
 apply (simp add: list_null_free)
 done

lemma list_non_empty_recursive: "list (lkup s) (x # xs) i \<Longrightarrow> list (lkup s) xs s[i]\<rightarrow>next" by auto

lemma list_non_empty_member: 
"\<lbrakk>list (lkup s) (x # xs) i; j \<in> set (x # xs)\<rbrakk> 
  \<Longrightarrow> j = x \<or> (list (lkup s) xs s[i]\<rightarrow>next \<and> j \<in> set xs)" by auto

(* Take a bit longer. *)
lemma list_next:"\<lbrakk>list (lkup s) xs i; j \<in> set xs; s[j]\<rightarrow>next \<noteq> NULL\<rbrakk> \<Longrightarrow> s[j]\<rightarrow>next \<in> set xs"
 apply (induction xs arbitrary: i j) using list_mem by auto 

lemma list_all_valid:"\<lbrakk>list (lkup s) xs i; j \<in> set xs\<rbrakk> \<Longrightarrow> is_valid_ll_C s j"
 apply (induction xs arbitrary: i j) by auto

lemma the_list_next_is_smaller:"\<lbrakk>list (lkup s) xs i; j \<in> set xs\<rbrakk>
       \<Longrightarrow> length (the_list (lkup s) s[j]\<rightarrow>next) < length (the_list (lkup s) j)"
 apply (induction xs arbitrary: i j)
 apply auto
 by (simp add: is_list_non_NULL linked_list.list_is_list the_list_non_NULL)

(* Awkward. Can this be generalized into something more intuitive? *)
lemma the_list_absurd:
  "\<lbrakk>is_valid_ll_C s x; x \<noteq> NULL; s[x]\<rightarrow>next = NULL; the_list (lkup s) x = []\<rbrakk> \<Longrightarrow> False"
by 
  (metis 
    is_list_non_NULL
    linked_list.get_ll_next_def
    linked_list.is_list_empty
    linked_list.lkup_def
    the_list_empty')

lemma path_null_list_imp: "list s xs i \<Longrightarrow> path s i xs NULL"
 using path_null_list by auto

lemma list_singleton: "\<lbrakk>list (lkup s) xs i; i \<noteq> NULL; s[i]\<rightarrow>next = NULL\<rbrakk> \<Longrightarrow> xs = [i]"
 by (cases xs, auto) 

lemma list_non_empty: 
"list (lkup s) (x # xs) i 
  \<Longrightarrow> i \<noteq> NULL \<and> x = i \<and> is_valid_ll_C s i \<and> list (lkup s) xs s[i]\<rightarrow>next"
 by auto

lemma list_member_has_sublist:"\<lbrakk>list (lkup s) xs i; j \<in> set xs\<rbrakk> \<Longrightarrow> \<exists> xs1 xs2. xs = xs1 @ xs2 \<and> list (lkup s) xs2 j"
 apply (induction xs arbitrary: i)
 apply auto
 using list_non_NULL apply auto[1]
 by (metis append_Cons)

lemma list_is_two_paths:"\<lbrakk>list (lkup s) xs i; j \<in> set xs \<rbrakk> \<Longrightarrow>  \<exists> xs1 xs2. xs = xs1 @ xs2 \<and> path (lkup s) i xs1 j \<and> path (lkup s) j xs2 NULL"
proof(induction xs arbitrary: i j)
  case Nil
  thus ?case by auto
next
  case (Cons x xs)
  have "s[i]\<rightarrow>next = NULL \<or> s[i]\<rightarrow>next \<noteq> NULL" by auto
  thus ?case
  proof
    assume "s[i]\<rightarrow>next = NULL"
    thus ?case using Cons by (metis append_Nil empty_iff linked_list.list_singleton linked_list.path.simps(1) linked_list.path_null_list list.set(1) local.list.simps(2) set_ConsD)
  next
    assume a1:"s[i]\<rightarrow>next \<noteq> NULL"
    have "x = j \<or> x \<noteq> j" by auto
    thus ?case
    proof
      assume a2:"x = j"
      thus ?case using a1 a2 Cons by (metis (no_types, hide_lams) append_Nil linked_list.list.simps(2) linked_list.path.simps(1) linked_list.path_null_list)
    next
      assume a2:"x \<noteq> j"
      then have h1:"list (lkup s) xs s[i]\<rightarrow>next" using Cons by auto
      then have h2:"j \<in> set xs" using a2 Cons by auto
      then obtain xs1 xs2 where "xs = xs1 @ xs2 \<and> path (lkup s) s[i]\<rightarrow>next xs1 j \<and> path (lkup s) j xs2 NULL" using Cons(1)[OF h1 h2] by auto
      then have "i # xs = i # xs1 @ xs2 \<and> path (lkup s) i (i # xs1) j \<and> path (lkup s) j xs2 NULL" using Cons by (metis linked_list.get_ll_next_def linked_list.list_non_empty linked_list.lkup_def path.simps(2))
      thus ?case by (metis Cons(2) append_Cons linked_list.list.simps(2))
    qed
  qed
qed
 
lemma list_hd_non_member_tail:"\<lbrakk>list (lkup s) xs i; xs \<noteq> []\<rbrakk> \<Longrightarrow> xs = [] \<or> hd xs \<notin> set (tl xs)"
apply (induction xs arbitrary: i)
apply auto
by 
  (metis 
    linked_list.get_ll_next_def 
    linked_list.list_all_valid 
    linked_list.list_head_not_in_list 
    linked_list.lkup_def)

lemma path_non_empty_non_null_start:"\<lbrakk>path (lkup s) i xs j; xs \<noteq> []\<rbrakk> \<Longrightarrow> i \<noteq> NULL" by auto

lemma path_extend:
"\<lbrakk>path (lkup s) i xs a; a \<noteq> NULL; is_valid_ll_C s a\<rbrakk> \<Longrightarrow> path (lkup s) i (xs@[a]) s[a]\<rightarrow>next"
proof(induction xs arbitrary:i)
  case Nil
  thus ?case by (metis append_Nil linked_list.get_ll_next_def path.simps lkup_def)
next
  case (Cons x xs)
  then have "i \<noteq> NULL \<and> is_valid_ll_C s a \<and> i = x \<and> path (lkup s) s[i]\<rightarrow>next xs a" 
    using lkup_def
    by (metis linked_list.get_ll_next_def option.distinct(1) option.sel path.simps(2))
  then have h1:"i = x" and h2:"path (lkup s) s[i]\<rightarrow>next xs a" and h3:"i \<noteq> NULL" and h4:"is_valid_ll_C s a" by auto
  then have "path (lkup s) s[i]\<rightarrow>next (xs @ [a]) s[a]\<rightarrow>next" using Cons(1)[OF h2 Cons(3) Cons(4)] by auto
  thus ?case 
    using h3 h4 h1 Cons.prems(1) append_Cons linked_list.get_ll_next_def 
    by (metis lkup_def option.simps(3) path.simps(2))
qed

lemma path_equal_endpoints:"path (lkup s) j [] j" by (meson linked_list.path.simps(1))
 
lemma list_path_no_cycles:"\<lbrakk>list (lkup s) xs i; j \<in> set xs; path (lkup s) j ys j\<rbrakk> \<Longrightarrow> ys = []"
proof (induction xs arbitrary: i)
  case Nil
  thus ?case by auto
next
  case (Cons x xs)
  have "j = i \<or> j \<noteq> i" using Cons by auto
  thus ?case
  proof
    assume "j = i"
    thus ?case using Cons by (meson append_self_conv2 list_split list_unique)
  next
    assume a:"j \<noteq> i"
    then have "x = i \<and> list (lkup s) xs (s[i]\<rightarrow>next)" using Cons list_non_empty by blast
    then have h1:"x = i" and h2:"list (lkup s) xs (s[i]\<rightarrow>next)" by auto
    thus ?case using Cons Cons(1)[OF h2 _ Cons(4)] a by auto
  qed
qed

lemma paths_preserve_list:
"\<lbrakk>list (lkup s) xs i; j \<in> set xs; path (lkup s) i xs1 j; path (lkup s) j xs2 NULL\<rbrakk> 
  \<Longrightarrow> xs = xs1 @ xs2"
proof (induction xs arbitrary: i)
  case Nil
  thus ?case by auto
next
  case (Cons x xs)
  have "j = i \<or> j \<noteq> i" using Cons by auto
  thus ?case
  proof
    assume "j = i"
    thus ?case using Cons list_path_no_cycles 
      by (metis append_self_conv2 list_unique path_null_list)
  next
    assume a:"j \<noteq> i"
    then have "x = i \<and> list (lkup s) xs (s[i]\<rightarrow>next)" using list_non_empty Cons by blast
    then have h1:"x = i" and h2:"list (lkup s) xs (s[i]\<rightarrow>next)" by auto
    thus ?case 
      using Cons(1)[OF h2 _ _ Cons(5)] Cons a by (meson list_split list_unique path_null_list) 
  qed
qed

lemma path_shorten:"\<lbrakk>path (lkup s) i xs NULL; i \<noteq> NULL\<rbrakk> \<Longrightarrow> path (lkup s) s[i]\<rightarrow>next (tl xs) NULL"
proof -
  assume a1:"path (lkup s) i xs NULL"
  and a2:"i \<noteq> NULL"
  have "s[i]\<rightarrow>next = NULL \<or> s[i]\<rightarrow>next \<noteq> NULL" by simp
  thus ?thesis
  proof 
    assume "s[i]\<rightarrow>next = NULL"
    thus ?thesis 
      using a1 a2 linked_list.path.simps(1) linked_list.path_null_list 
            linked_list.list_singleton list.sel(3) 
      by fastforce
  next
    assume "s[i]\<rightarrow>next \<noteq> NULL"
    thus ?thesis by (metis a1 a2 linked_list.path_null_list list.sel(3) list_non_empty path_next)
  qed
qed

lemma find_insertion_1_loop_step:
assumes a1:"list (lkup s) xs i"
and a2:"path (lkup s) i xs1 a"
and a3:"\<forall>x\<in>set xs1. sint s[x]\<rightarrow>val \<le> v"
and a4:"path (lkup s) a xs2 NULL"
and a5:"a \<noteq> NULL"
and a6:"sint s[a]\<rightarrow>val \<le> v"
and a7:"a \<in> set xs"
shows "\<exists>xs1. path (lkup s) i xs1 s[a]\<rightarrow>next 
       \<and> (\<exists>xs2. path (lkup s) s[a]\<rightarrow>next xs2 NULL) 
       \<and> (\<forall>x\<in>set xs1. sint s[x]\<rightarrow>val \<le> v)"
proof - 
  have h1:"path (lkup s) i (xs1 @ [a]) s[a]\<rightarrow>next" using path_extend[OF a2 a5 list_all_valid[OF a1 a7]] by simp
  then have h2:"path (lkup s) s[a]\<rightarrow>next (tl xs2) NULL" using path_shorten[OF a4 a5] by simp
  then have h3:"\<forall>x\<in>set (xs1@[a]). sint s[x]\<rightarrow>val \<le> v" using a3 a6 by simp
  thus ?thesis using h1 h2 h3 by metis
qed

text{*

Correctness of find_insertion when the input list is not null and the head of the list is less 
than or equal to value supplied.

*}

lemma find_insertion_1:
"\<lbrace> \<lambda> (s::lifted_globals). 
  s' = s
  \<and> i \<noteq> NULL
  \<and> sint s'[i]\<rightarrow>val \<le> v
  \<and> list (lkup s) xs i \<rbrace>
  find_insertion' v i
\<lbrace> \<lambda> r s.
  s' = s
  \<and> r \<in> set xs
  \<and> (s[r]\<rightarrow>next = NULL \<or> (s[r]\<rightarrow>next \<noteq> NULL \<and>  v < sint s[s[r]\<rightarrow>next]\<rightarrow>val))
  \<and> (\<exists> xs1 xs2.
       path (lkup s) i xs1 s[r]\<rightarrow>next 
       \<and> path (lkup s) s[r]\<rightarrow>next xs2 NULL
       \<and> (\<forall> x \<in> set xs1. sint s[x]\<rightarrow>val \<le> v))
\<rbrace>!"
 apply (rule validNF_assume_pre)
 apply (unfold find_insertion'_def)
 apply (subst whileLoop_add_inv [where 
  I = " \<lambda> (it,last,cond) s. 
       s = s'
       \<and> (cond \<noteq> 0 \<longrightarrow> it \<noteq> NULL \<and> sint s[it]\<rightarrow>val \<le> v \<and> it \<in> set xs)
       \<and> (cond = 0 \<longrightarrow> last \<noteq> NULL \<and> (it = NULL \<or> v < sint s[it]\<rightarrow>val))
       \<and> (last \<noteq> NULL \<longrightarrow> s[last]\<rightarrow>next = it \<and> last \<in> set xs)
       \<and> (\<exists> xs1 xs2. path (lkup s) i xs1 it \<and> path (lkup s) it xs2 NULL \<and> (\<forall> x \<in> set xs1. sint s[x]\<rightarrow>val \<le> v))
" 
  and M = "\<lambda>((it,r,_),s). length (the_list (lkup s) it)"])
 apply wp
    apply (clarsimp,auto intro: list_all_valid list_next list_mem the_list_next_is_smaller path_null_list_imp the_list_absurd find_insertion_1_loop_step)[1]
   apply (clarsimp, auto)
  apply wp
 apply (auto intro: list_mem list_all_valid) 
 apply (metis empty_iff linked_list.path.simps(1) linked_list.path_null_list list.set(1))
done

text{*

Correctness of find_insertion when the input list is null.

*}

lemma find_insertion_2:
"\<lbrace> \<lambda> (s::lifted_globals). 
  s' = s
  \<and> i = NULL
  \<and> list (lkup s) xs i \<rbrace>
  find_insertion' v i
\<lbrace> \<lambda> r s.
  s' = s
  \<and> r = NULL
\<rbrace>!"
 apply (unfold find_insertion'_def)
 apply (subst whileLoop_unroll)
 apply wp
    apply (rule validNF_false_pre)
   apply (rule validNF_false_pre)
  apply wp
 apply auto
done

text{*

Correctness of find_insertion when the input list is not null and the head of the list is greater
than the value supplied to find_insertion.

*}

lemma find_insertion_3:
"\<lbrace> \<lambda> (s::lifted_globals). 
  s' = s
  \<and> i \<noteq> NULL
  \<and> v < sint s'[i]\<rightarrow>val
  \<and> list (lkup s) xs i \<rbrace>
  find_insertion' v i
\<lbrace> \<lambda> r s.
  s' = s
  \<and> r = NULL
  \<and> v < sint s'[i]\<rightarrow>val
\<rbrace>!"
 apply (unfold find_insertion'_def)
 apply (subst whileLoop_unroll)
 apply wp
    apply (rule validNF_false_pre)
   apply (rule validNF_false_pre)
  apply wp
 apply (auto intro: list_all_valid list_mem) 
done

lemma find_insertion_pre_part:
"\<And>s. s' = s \<and> list (lkup s) xs i
 \<Longrightarrow> ((s' = s \<and> i \<noteq> NULL \<and> sint s'[i]\<rightarrow>val \<le> v \<and> list (lkup s) xs i)
     \<or> (s' = s \<and> i = NULL \<and> list (lkup s) xs i)
     \<or> (s' = s \<and> i \<noteq> NULL \<and> v < sint s'[i]\<rightarrow>val \<and> list (lkup s) xs i))"
by auto

lemma find_insertion:
"
\<lbrace> \<lambda> (s::lifted_globals). 
  s' = s
  \<and> list (lkup s) xs i \<rbrace>
  find_insertion' v i
\<lbrace> \<lambda> r s.
  (s' = s \<and> r \<in> set xs \<and>
                     (s[r]\<rightarrow>next = NULL \<or> s[r]\<rightarrow>next \<noteq> NULL \<and> v < sint s[s[r]\<rightarrow>next]\<rightarrow>val) \<and>
                     (\<exists>xs1 xs2. path (lkup s) i xs1 s[r]\<rightarrow>next \<and> path (lkup s) s[r]\<rightarrow>next xs2 NULL \<and> (\<forall>x\<in>set xs1. sint s[x]\<rightarrow>val \<le> v)) \<or>
            s' = s \<and> r = NULL) \<or>
           s' = s \<and> r = NULL \<and> v < sint s'[i]\<rightarrow>val
\<rbrace>!"
using validNF_weaken_pre[OF 
        validNF_vcg_disj_lift[OF 
          validNF_vcg_disj_lift[OF find_insertion_1 find_insertion_2]  
          find_insertion_3, 
          of s' i v xs s' xs s' xs],
        of "\<lambda> s . s' = s \<and> list (lkup s) xs i"] find_insertion_pre_part by simp


lemma else_branch:"\<not> C \<Longrightarrow> Q \<Longrightarrow> if C then P else Q"
 by auto

lemma next_update_preserve_validity:"is_valid_ll_C s i = is_valid_ll_C s[j\<rightarrow>next := x] i"
  by auto

lemma next_update_preserve_untouched_state:"x \<noteq> y \<Longrightarrow> lkup s x = lkup s[y\<rightarrow>next := v] x"
 apply(unfold lkup_def) by (simp add: linked_list.update_ll_next_def)

lemma next_update_preserve_path:"\<lbrakk>i \<notin> set xs; path (lkup s) j xs k\<rbrakk> \<Longrightarrow> path (lkup s[i\<rightarrow>next := l]) j xs k"
  apply(induction xs arbitrary: j)
  apply auto
  using linked_list.next_update_preserve_untouched_state by auto

lemma non_member_next_update_preserves_list:"\<lbrakk>list (lkup s) xs i; n \<notin> set xs\<rbrakk> \<Longrightarrow> list (lkup s[n\<rightarrow>next := j]) xs i"
proof (induction xs arbitrary: i) 
  case Nil
  thus ?case by auto
next
  case (Cons x xs)
  then have h1:"list (lkup s) xs s[i]\<rightarrow>next" and h2:"x = i" by auto 
  have h3:"n \<notin> set xs" using Cons by auto
  have h4:"i \<noteq> n" using Cons h2 by auto
  have h5:"is_valid_ll_C s[n\<rightarrow>next := j] i" using next_update_preserve_validity Cons by auto
  have h6:"i \<noteq> NULL" using Cons by auto
  obtain di where h7:"lkup s i = Some di" using Cons by auto
  have h8:"lkup s[n\<rightarrow>next := j] i = Some di" using next_update_preserve_untouched_state[OF h4,of s x] h7 using h4 linked_list.next_update_preserve_untouched_state by presburger
  have h9:"s[n\<rightarrow>next := j][i]\<rightarrow>next = next_C di" using h8 by auto
  have h10:"s[i]\<rightarrow>next = s[n\<rightarrow>next := j][i]\<rightarrow>next" using h4 by simp
  have h11:"list (lkup s[n\<rightarrow>next := j]) xs s[n\<rightarrow>next := j][i]\<rightarrow>next" using Cons(1)[OF h1 h3] h10 by auto
  thus ?case using h2 h6 h8 h11 h9 by auto
qed

lemma path_one_step:"\<lbrakk>path (lkup s) i xs j; i\<noteq> NULL; xs \<noteq> []\<rbrakk> \<Longrightarrow> path (lkup s) s[i]\<rightarrow>next (tl xs) j"
 apply(induction xs arbitrary: i) by auto

lemma path_cannot_cycle:"\<lbrakk>list (lkup s) xs i; j \<in> set xs; path (lkup s) i ys s[j]\<rightarrow>next\<rbrakk> \<Longrightarrow> ys \<noteq> []"
sorry


lemma lkup_valid_eval:"is_valid_ll_C s i \<Longrightarrow> lkup s i = Some s[i]"
  using lkup_def by metis

lemma list_last_element:"\<lbrakk>list (lkup s) xs i; n \<notin> set xs;  r \<in> set xs; s[r]\<rightarrow>next = NULL\<rbrakk> \<Longrightarrow> last xs = r"
  apply(induction xs arbitrary: i) by auto

lemma hd_last_not_equal_if_distinct:"\<lbrakk>distinct xs; length xs > 1\<rbrakk> \<Longrightarrow> hd xs \<noteq> last xs"
  apply(induction xs) by auto

lemma insert_front:
"\<lbrakk>n \<noteq> NULL; is_valid_ll_C s n; list (lkup s) xs i; n \<notin> set xs\<rbrakk> 
   \<Longrightarrow> list (lkup s[n\<rightarrow>next := i]) (n # xs) n"
proof -
  assume a1:"n \<noteq> NULL"
  assume a2:"is_valid_ll_C s n"
  assume a3:"list (lkup s) xs i"
  assume a4:"n \<notin> set xs"
  have h1:"is_valid_ll_C s[n\<rightarrow>next := i] n" using next_update_preserve_validity a2 by auto
  have h2:"list (lkup s[n\<rightarrow>next := i]) xs i" using non_member_next_update_preserves_list[OF a3 a4, of i] by auto
  obtain dn where h3:"lkup s[n\<rightarrow>next := i] n = Some dn" by (metis h1 lkup_def)
  have h4:"next_C dn = i" using lkup_conv[OF h3] by simp
  thus ?thesis using a1 h3 h2 h4 by auto
qed

lemma insert_back:
"\<lbrakk>n \<noteq> NULL; is_valid_ll_C s n; list (lkup s) xs i; n \<notin> set xs;  last xs = r; xs \<noteq> []\<rbrakk> 
   \<Longrightarrow> list (lkup s[n\<rightarrow>next := NULL][r\<rightarrow>next := n]) (xs@[n]) i  \<and> insert n (set xs) = set (xs@[n])"
proof (induction xs arbitrary: i)
  case Nil
  thus ?case by auto
next
  case (Cons x xs)
  have h2:"list (lkup s) xs s[i]\<rightarrow>next" and h3:"x = i" and h4:"i \<noteq> NULL" using Cons by auto
  have h5:"(last xs = r \<and> xs \<noteq> []) \<or> xs = []" using Cons by auto
  thus ?case
  proof
    assume a:"last xs = r \<and> xs \<noteq> []"
    have "length (x # xs) > 1" using a Cons by auto
    then have "r \<noteq> i" by (metis Cons.prems(3) Cons.prems(5) h3 list.sel(1) hd_last_not_equal_if_distinct list_distinct)
    then have h6:"lkup s i = lkup s[n\<rightarrow>next := NULL][r\<rightarrow>next := n] i" by (metis List.list.simps(15) h3 insert_iff Cons next_update_preserve_untouched_state )
    have "is_valid_ll_C s[n\<rightarrow>next := NULL][r\<rightarrow>next := n] i" using Cons next_update_preserve_validity linked_list.list_non_empty by presburger
    thus ?case using Cons h2 h3 h4 a h6 by auto
  next 
    assume "xs = []"
    then have "list (lkup s[n\<rightarrow>next := NULL][r\<rightarrow>next := n]) ((x # xs) @ [n]) i" using Cons 
    by (metis (no_types, hide_lams) append.simps(1) append.simps(2) empty_iff insert_front last_in_set linked_list.heap_abs_simps(36) linked_list.list_empty list.set(1) list_non_empty set_ConsD) 
    thus ?case using Cons by auto
  qed
qed

lemma insert_middle:" \<lbrakk>n \<noteq> NULL; is_valid_ll_C s n; list (lkup s) xs i; n \<notin> set xs; r \<in> set xs; path (lkup s) i xs1 s[r]\<rightarrow>next; path (lkup s) s[r]\<rightarrow>next xs2 NULL\<rbrakk>
       \<Longrightarrow> list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) (xs1@[n]@xs2) i \<and> insert n (set xs) = set (xs1@[n]@xs2)"
proof (induction xs arbitrary: i xs1)
  case Nil
  thus ?case by auto
next 
  case (Cons x xs)
  then have h1:"x = i" by auto
  then have "r = x \<or> r \<in> set xs" using Cons by auto
  thus ?case
  proof
    assume a:"r = x"
    then have h2:"r = i" using h1 by auto
    then have h3:"r \<notin> set xs2" using a Cons list_distinct by (metis linked_list.get_ll_next_def linked_list.list_head_not_in_list linked_list.path_null_list list_non_empty lkup_def)
    then have "xs1 @ xs = i # xs"
      by (metis (no_types) Cons h2 h1 linked_list.list_non_empty_recursive linked_list.list_split linked_list.list_unique)
    then have h4:"xs1 = [r]" using h2 by auto
    then have "path (lkup s) i [r] s[r]\<rightarrow>next" using Cons by auto
    then have h5:"path (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next]) i [r] s[n\<rightarrow>next := s[r]\<rightarrow>next][i]\<rightarrow>next" using Cons by (metis h2 fun_upd_apply linked_list.heap_abs_simps(16) linked_list.next_update_preserve_path singleton_set)
    then have h6:"n \<notin> set xs2" using Cons by (metis List.list.simps(15) h2 insert_iff linked_list.list_non_empty_recursive linked_list.list_the_list path_null_list)
    then have h7:"path (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next]) s[n\<rightarrow>next := s[r]\<rightarrow>next][r]\<rightarrow>next xs2 NULL" using next_update_preserve_path[OF h6 Cons(8)] Cons by auto
    then have h8:"path (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) n (n#xs2) NULL" using Cons by (metis h3 h6 linked_list.insert_front linked_list.non_member_next_update_preserves_list linked_list.path_null_list set_ConsD)
    then have h9:"x = i" using a h2 by auto
    then have h10:"i \<noteq> NULL" using Cons by auto
    have h11:"lkup s[n\<rightarrow>next := s[r]\<rightarrow>next] r \<noteq> None \<or> [] = xs1" using h5 by auto
    then have h12:"list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) (xs1@[n]@xs2) i" using h11 h10 h9 h4 h7 h2 h4 
    by (metis Cons.prems(1) Cons.prems(2) Cons.prems(4) Cons.prems(7) List.list.simps(15) append_Cons append_Nil h3 h6 insert_iff linked_list.insert_front linked_list.lkup_def linked_list.path_null_list)
    thus ?thesis using Cons by (metis (mono_tags, hide_lams) List.list.simps(15) a append_Cons append_Nil h4 h9 insert_commute linked_list.list_non_empty_recursive linked_list.list_the_list path_null_list)
  next
    assume a:"r \<in> set xs"
    then have h1:"list (lkup s) xs s[i]\<rightarrow>next" using Cons by auto
    then have h2:"path (lkup s) s[i]\<rightarrow>next (tl xs1) s[r]\<rightarrow>next" using path_one_step[OF Cons(7)] 
      using Cons.prems(3) Cons.prems(5) Cons.prems(6) linked_list.list_non_empty linked_list.path_cannot_cycle by presburger
    then have h3:"n \<notin> set xs" using Cons by auto
    then have h4:"list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) (tl xs1 @ [n] @ xs2) s[i]\<rightarrow>next" and h45:"insert n (set xs) = set (tl xs1 @ [n] @ xs2)"
    using Cons(1)[OF Cons(2) Cons(3) h1 h3 a h2 Cons(8)] by auto
    then have h5:"list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) (tl xs1 @ [n] @ xs2) s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n][i]\<rightarrow>next" 
    by (metis a append.simps(1) distinct.simps(2) fun_upd_apply in_set_conv_decomp linked_list.heap_abs_simps(16) linked_list.list_distinct local.Cons(4) local.Cons(5) local.list.simps(2))
    then have h6:"i = x" using Cons by (meson linked_list.list.simps(2))
    then have h7:"x \<noteq> NULL" using Cons using linked_list.list_non_empty by blast
    then obtain a where  h8:"lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n] i = Some a" by (meson Cons.prems(3) linked_list.heap_abs_simps(36) linked_list.list_non_empty linked_list.lkup_def)
    then obtain h9:"list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) (tl xs1 @ [n] @ xs2) (next_C a)"
    by (metis Cons.prems(3) Cons.prems(4) a append_Nil distinct.simps(2) h4 in_set_conv_decomp linked_list.get_ll_next_def linked_list.list_distinct linked_list.list_non_empty linked_list.lkup_def linked_list.next_update_preserve_untouched_state option.sel)
    then have h11:"list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) ((x # tl xs1) @ [n] @ xs2) i" using h6 h7 h8 h9 by auto
    then have h12:"xs1 = x # tl xs1" using path_one_step[OF Cons(7)] h7 h6
    by (metis Cons.prems(1) Cons.prems(6) append_Cons append_Nil h1 h3 h4 linked_list.list.simps(2) linked_list.path.simps(2) list.sel(2) list.sel(3) list_mem neq_Nil_conv)  
    then have h13:"list (lkup s[n\<rightarrow>next := s[r]\<rightarrow>next][r\<rightarrow>next := n]) (xs1 @ [n] @ xs2) i" using h11 h12 by auto
    thus ?thesis using h13 h45 by (metis List.list.simps(15) append_Cons h12 insert_commute)
  qed
qed

lemma gets_maintains_state:
"
\<lbrace>\<lambda>s. s' = s 
  \<and> n \<noteq> NULL 
  \<and> is_valid_ll_C s n \<and> s[n]\<rightarrow>next = NULL 
  \<and> list (lkup s) xs' i 
  \<and> n \<notin> set xs' \<rbrace> 
guard (\<lambda> s.  is_valid_ll_C s n)
\<lbrace>\<lambda> _ s. s' = s\<rbrace>!"
 by (simp add: guard_def validNF_alt_def validNF_state_assert state_assert_def validNF_weaken_pre)

lemma "\<lbrace> \<lambda> (s::lifted_globals). 
  s' = s
  \<and> n \<noteq> NULL
  \<and> is_valid_ll_C s n
  \<and> s[n]\<rightarrow>next = NULL
  \<and> list (lkup s) xs' i 
  \<and> n \<notin> set xs'\<rbrace>
  insert' n i
\<lbrace> \<lambda> r s. (\<exists> xs . list (lkup s) xs r \<and> set (n # xs') = set xs)\<rbrace>!"
 apply (rule validNF_assume_pre)
 apply (unfold insert'_def)
 apply wp
   apply (rule validNF_chain[OF find_insertion,of "\<lambda> s. s' = s" s' xs'],simp)
   apply safe
      apply (rule else_branch)
       apply (simp add: list_member_not_null)
      apply (auto intro: list_all_valid)[1]
      using insert_back apply (metis linked_list.list_last_element list.distinct(1) list.set_cases)
     apply (rule else_branch)
      apply (simp add: list_member_not_null) 
     apply (auto intro: list_all_valid, metis insert_middle)[1]
    apply (auto intro: list_all_valid insert_front)[1]
   apply (auto intro: list_all_valid insert_front)[1]
  apply (rule validNF_gets)
 apply (rule gets_maintains_state)
done

end